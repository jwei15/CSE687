<DOCTYPE !HTML></div>
<html>
  <head>
    <Title>ActionsAndRules.h</Title>
    <style>
      body <input id = _6 type = "checkbox"><label class = "drop" for = "_6"></label><div>{
        padding:15px 40px;
        font-family: Consolas;
        font-size: 1.25em;
        font-weight: normal;
      }</div>
      </style>
      <link rel="stylesheet"  href="../foldingformat.css" />
  </head>

  <body>
    <h3>Dependencies: 
      <a href="Parser.h.html">Parser.h</a>
      <a href="GrammarHelpers.h.html">GrammarHelpers.h</a>
      <a href="ITokenCollection.h.html">ITokenCollection.h</a>
      <a href="ScopeStack.h.html">ScopeStack.h</a>
      <a href="Toker.h.html">Toker.h</a>
      <a href="Semi.h.html">Semi.h</a>
      <a href="AbstrSynTree.h.html">AbstrSynTree.h</a>
      <a href="Logger.h.html">Logger.h</a>
      <a href="FileSystem.h.html">FileSystem.h</a>
    </h3>    <pre>
#ifndef ACTIONSANDRULES_H
#define ACTIONSANDRULES_H
<input id = _37 type = "checkbox"><label class = "drop" for = "_37"></label><div>/////////////////////////////////////////////////////////////////////
//  ActionsAndRules.h - declares new parsing rules and actions     //
//  ver 3.5                                                        //
//  Language:      Visual C++ 2008, SP1                            //
//  Platform:      Dell Precision T7400, Vista Ultimate SP1        //
//  Application:   Prototype for CSE687 Pr1, Sp09                  //
//  Author:        Jim Fawcett, CST 4-187, Syracuse University     //
//                 (315) 443-3948, jfawcett@twcny.rr.com           //
/////////////////////////////////////////////////////////////////////</div>
<input id = _91 type = "checkbox"><label class = "drop" for = "_91"></label><div>/*
  Module Operations: 
  ==================
  This module defines several action classes.  Its classes provide 
  specialized services needed for specific applications.  The modules
  Parser, Semiression, and Tokenizer, are intended to be reusable
  without change.  This module provides a place to put extensions of
  these facilities and is not expected to be reusable. 

  Required files
  ==============
    - Parser.h, Parser.cpp, ScopeStack.h, ScopeStack.cpp,
      ActionsAndRules.h, ActionsAndRules.cpp, ConfigureParser.cpp,
      ITokenCollection.h, Semiression.h, Semiression.cpp, tokenizer.h, tokenizer.cpp

  Maintenance History:
  ====================
  ver 3.5 : 11 Feb 2019
  - small changes spread over many of the Rule and Action classes, caused
    by changing the lexical scanner, which forced some changes to the
    scanner's interface (sigh!)
  ver 3.4 : 28 May 2017
  - Added several tests for scopestack size in actions to fix exceptions
    thrown when processing code that won't compile.
  ver 3.3 : 26 Feb 2017
  - Fixed bug in public data analysis with changes to rule CppDeclaration
    and its action HandleCppDeclaration.
  - Fixed a minor bug in name collection for operators.  Won't be important
    for dependency analysis.
  ver 3.2 : 28 Aug 16
  - fixed errors in many rules and actions based on lots of testing
  - cleaned up text, removing comments and improving prologues
  ver 3.1 : 23 Aug 16
  - qualified input pointers in rules and actions as const
  - cleaned up code by removing unreachables and commented code, and by simplifying 
  ver 3.0 : 06 Aug 16
  - Added use of AbstrSynTree
  - Added new rules and actions
  - Renamed and modified most of the other actions and rules
  ver 2.1 : 15 Feb 16
  - small functional change to a few of the actions changes display strategy
  - preface the (new) Toker and Semi with Lexer namespace
  ver 2.0 : 01 Jun 11
  - added processing on way to building strong code analyzer
  ver 1.1 : 17 Jan 09
  - changed to accept a pointer to interfaced ITokenCollection instead
    of a Semiression
  ver 1.0 : 12 Jan 06
  - first release

  Planned Changes:
  ================
  C++ lambda detection needs strengthening
*/</div>
//
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include "Parser.h"
#include "../GrammarHelpers/GrammarHelpers.h"
#include "../SemiExpression/ITokenCollection.h"
#include "../ScopeStack/ScopeStack.h"
#include "../Tokenizer/Toker.h"
#include "../SemiExpression/Semi.h"
#include "../AbstractSyntaxTree/AbstrSynTree.h"
#include "../Logger/Logger.h"
#include "../FileSystem/FileSystem.h"

namespace CodeAnalysis
<input id = _109 type = "checkbox"><label class = "drop" for = "_109"></label><div>{  
  ///////////////////////////////////////////////////////////////////
  // Repository instance is used to share resources
  // among all actions.

<input id = _113 type = "checkbox"><label class = "drop" for = "_113"></label><div>  enum Language <input id = _114 type = "checkbox"><label class = "drop" for = "_114"></label><div>{ C /* not implemented */, Cpp, CSharp };</div></div>

  class Repository  // application specific
  <input id = _117 type = "checkbox"><label class = "drop" for = "_117"></label><div>{
  public:
    using Rslt = Logging::StaticLogger&lt;0&gt;;  // use for application results
    using Demo = Logging::StaticLogger&lt;1&gt;;  // use for demonstrations of processing
    using Dbug = Logging::StaticLogger&lt;2&gt;;  // use for debug output
    using Package = std::string;
    using Path = std::string;

  private:
    Language language_ = Language::Cpp;
    Path path_;
    ScopeStack&lt;ASTNode*&gt; stack;
    AbstrSynTree ast;
    ASTNode* pGlobalScope;
    Package package_;
    Lexer::Toker* p_Toker;
    Access currentAccess_ = Access::publ;
    static Repository* instance;
  
  public:
    
    Repository(Lexer::Toker* pToker) : ast(stack)
    <input id = _139 type = "checkbox"><label class = "drop" for = "_139"></label><div>{
      p_Toker = pToker;
      pGlobalScope = stack.top();  // installed in AST constructor
      instance = this;
    }</div>

    ~Repository()
    <input id = _146 type = "checkbox"><label class = "drop" for = "_146"></label><div>{
      Dbug::write("\n  deleting repository");
    }</div>

    Language& language() <input id = _150 type = "checkbox"><label class = "drop" for = "_150"></label><div>{ return language_; }</div>

    Package& package() <input id = _152 type = "checkbox"><label class = "drop" for = "_152"></label><div>{ return package_; }</div>

    Path& currentPath() <input id = _154 type = "checkbox"><label class = "drop" for = "_154"></label><div>{ return path_; }</div>

    Access& currentAccess() <input id = _156 type = "checkbox"><label class = "drop" for = "_156"></label><div>{ return currentAccess_; }</div>

    static Repository* getInstance() <input id = _158 type = "checkbox"><label class = "drop" for = "_158"></label><div>{ return instance; }</div>

    ScopeStack&lt;ASTNode*&gt;& scopeStack() <input id = _160 type = "checkbox"><label class = "drop" for = "_160"></label><div>{ return stack; }</div>

    AbstrSynTree& AST() <input id = _162 type = "checkbox"><label class = "drop" for = "_162"></label><div>{ return ast; }</div>

    ASTNode* getGlobalScope() <input id = _164 type = "checkbox"><label class = "drop" for = "_164"></label><div>{ return pGlobalScope; }</div>

    Lexer::Toker* Toker() <input id = _166 type = "checkbox"><label class = "drop" for = "_166"></label><div>{ return p_Toker; }</div>

    size_t lineCount() 
    <input id = _169 type = "checkbox"><label class = "drop" for = "_169"></label><div>{ 
      return (size_t)(p_Toker-&gt;lineCount()); 
    }</div>
  };</div>

  ///////////////////////////////////////////////////////////////
  // rule to detect beginning of scope

  class BeginScope : public IRule
  <input id = _178 type = "checkbox"><label class = "drop" for = "_178"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _181 type = "checkbox"><label class = "drop" for = "_181"></label><div>{
      GrammarHelper::showParseDemo("Test begin scope", *pTc);

      // don't parse Semi with single semicolon token

      if (pTc-&gt;size() == 1 && (*pTc)[0] == ";")
        return IRule::Stop;

      if (pTc-&gt;contains("{"))
      <input id = _190 type = "checkbox"><label class = "drop" for = "_190"></label><div>{
        doActions(pTc);
      }</div>
      return IRule::Continue;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to handle scope stack at beginning of scope

  class HandleBeginScope : public IAction
  <input id = _201 type = "checkbox"><label class = "drop" for = "_201"></label><div>{
    Repository* p_Repos;
  public:
    HandleBeginScope(Repository* pRepos)
    <input id = _205 type = "checkbox"><label class = "drop" for = "_205"></label><div>{
      p_Repos = pRepos;
    }</div>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _209 type = "checkbox"><label class = "drop" for = "_209"></label><div>{
      GrammarHelper::showParseDemo("handle begin scope", *pTc);

      ASTNode* pElem = new ASTNode;
      pElem-&gt;type_ = "anonymous";
      pElem-&gt;name_ = "none";
      pElem-&gt;package_ = p_Repos-&gt;package();
      pElem-&gt;startLineCount_ = p_Repos-&gt;lineCount();
      pElem-&gt;endLineCount_ = 1;
      pElem-&gt;path_ = p_Repos-&gt;currentPath();
<input id = _221 type = "checkbox"><label class = "drop" for = "_221"></label><div>      /*
       * make this ASTNode child of ASTNode on stack top
       * then push onto stack
       */</div>
      p_Repos-&gt;AST().add(pElem);
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // rule to detect end of scope

  class EndScope : public IRule
  <input id = _231 type = "checkbox"><label class = "drop" for = "_231"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _234 type = "checkbox"><label class = "drop" for = "_234"></label><div>{
      GrammarHelper::showParseDemo("Test end scope", *pTc);

      size_t posCloseBrace;
      pTc-&gt;find("}", posCloseBrace);
      if (posCloseBrace &lt; pTc-&gt;size())
      <input id = _240 type = "checkbox"><label class = "drop" for = "_240"></label><div>{
        doActions(pTc);
        return IRule::Stop;
      }</div>
      return IRule::Continue;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to handle scope stack at end of scope

  class HandleEndScope : public IAction
  <input id = _252 type = "checkbox"><label class = "drop" for = "_252"></label><div>{
    Repository* p_Repos;
  public:
    using Dbug = Logging::StaticLogger&lt;2&gt;;

    HandleEndScope(Repository* pRepos)
    <input id = _258 type = "checkbox"><label class = "drop" for = "_258"></label><div>{
      p_Repos = pRepos;
    }</div>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _262 type = "checkbox"><label class = "drop" for = "_262"></label><div>{
      GrammarHelper::showParseDemo("Handle end scope", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* pElem = p_Repos-&gt;AST().pop();
      if (pElem == nullptr)
        return;

      pElem-&gt;endLineCount_ = p_Repos-&gt;lineCount();
      if (pElem-&gt;type_ == "class" || pElem-&gt;type_ == "struct")
        (pElem-&gt;endLineCount_)++;

      p_Repos-&gt;currentAccess() = Access::priv;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // rule to detect access for C++

  class DetectAccessSpecifier : public IRule
  <input id = _284 type = "checkbox"><label class = "drop" for = "_284"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _287 type = "checkbox"><label class = "drop" for = "_287"></label><div>{
      GrammarHelper::showParseDemo("Test access spec", *pTc);

      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      size_t pos;
      pTc-&gt;find(":", pos);
      if (0 &lt; pos && pos &lt; pTc-&gt;size())
      <input id = _297 type = "checkbox"><label class = "drop" for = "_297"></label><div>{
        const std::string tok = (*pTc)[pos - 1];
        if (tok == "public" || tok == "protected" || tok == "private")
        <input id = _300 type = "checkbox"><label class = "drop" for = "_300"></label><div>{
          doActions(pTc);
          return IRule::Stop;
        }</div>
      }</div>
      return IRule::Continue;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to handle access specifier

  class HandleAccessSpecifier : public IAction
  <input id = _313 type = "checkbox"><label class = "drop" for = "_313"></label><div>{
    Repository* p_Repos;

  public:
    HandleAccessSpecifier(Repository* pRepos)
    <input id = _318 type = "checkbox"><label class = "drop" for = "_318"></label><div>{
      p_Repos = pRepos;
    }</div>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _322 type = "checkbox"><label class = "drop" for = "_322"></label><div>{
      GrammarHelper::showParseDemo("Handle access spec: ", *pTc);

      std::string tok = (*pTc)[pTc-&gt;size() - 2];
      Access& access = p_Repos-&gt;currentAccess();
      if (tok == "public")
        access = Access::publ;
      else if (tok == "protected")
        access = Access::prot;
      else
        access = Access::priv;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // rule to detect preprocessor statements

  class PreprocStatement : public IRule
  <input id = _340 type = "checkbox"><label class = "drop" for = "_340"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _343 type = "checkbox"><label class = "drop" for = "_343"></label><div>{
      GrammarHelper::showParseDemo("Test preproc statement: ", *pTc);

      size_t pPos;
      pTc-&gt;find("#", pPos);
      if (pPos &lt; pTc-&gt;size())
      <input id = _349 type = "checkbox"><label class = "drop" for = "_349"></label><div>{
        doActions(pTc);
        return IRule::Stop;
      }</div>
      return IRule::Continue;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to add Semi to scope stack top statements_

  class HandlePreprocStatement : public IAction
  <input id = _361 type = "checkbox"><label class = "drop" for = "_361"></label><div>{
    Repository* p_Repos;

  public:
    HandlePreprocStatement(Repository* pRepos)
    <input id = _366 type = "checkbox"><label class = "drop" for = "_366"></label><div>{
      p_Repos = pRepos;
    }</div>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _370 type = "checkbox"><label class = "drop" for = "_370"></label><div>{
      GrammarHelper::showParseDemo("Handle preproc statement: ", *pTc);

      Lexer::ITokenCollection* pClone = pTc-&gt;clone();
      if (p_Repos-&gt;scopeStack().size() == 0)
        return;
      ASTNode* pElem = p_Repos-&gt;scopeStack().top();
      pElem-&gt;statements_.push_back(pClone);

      GrammarHelper::showParse("Preproc Stmt", *pTc);
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // rule to detect namespace statements

  class NamespaceDefinition : public IRule
  <input id = _387 type = "checkbox"><label class = "drop" for = "_387"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _390 type = "checkbox"><label class = "drop" for = "_390"></label><div>{
      GrammarHelper::showParseDemo("Test namespace definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      <input id = _395 type = "checkbox"><label class = "drop" for = "_395"></label><div>{
        size_t len;
        tc.find("namespace", len);
        if (len &lt; tc.size())
        <input id = _399 type = "checkbox"><label class = "drop" for = "_399"></label><div>{
          doActions(pTc);
          return IRule::Stop;
        }</div>
      }</div>
      return IRule::Continue;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to add namespace info to scope stack top

  class HandleNamespaceDefinition : public IAction
  <input id = _412 type = "checkbox"><label class = "drop" for = "_412"></label><div>{
    Repository* p_Repos;

  public:
    HandleNamespaceDefinition(Repository* pRepos)
    <input id = _417 type = "checkbox"><label class = "drop" for = "_417"></label><div>{
      p_Repos = pRepos;
    }</div>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _421 type = "checkbox"><label class = "drop" for = "_421"></label><div>{
      GrammarHelper::showParseDemo("Handle namespace definition: ", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();

      size_t pos;
      pTc-&gt;find("namespace", pos);
      std::string name = (*pTc)[pos + 1];
      top-&gt;type_ = "namespace";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();

      GrammarHelper::showParse("namespace def", *pTc);
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // rule to detect class statements

  class ClassDefinition : public IRule
  <input id = _444 type = "checkbox"><label class = "drop" for = "_444"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _447 type = "checkbox"><label class = "drop" for = "_447"></label><div>{
      GrammarHelper::showParseDemo("Test class definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      <input id = _452 type = "checkbox"><label class = "drop" for = "_452"></label><div>{
        size_t len;
        tc.find("class", len);
        if (len &lt; tc.size())
        <input id = _456 type = "checkbox"><label class = "drop" for = "_456"></label><div>{
          doActions(pTc);
          return IRule::Stop;
        }</div>
        if (tc.contains("interface"))
        <input id = _461 type = "checkbox"><label class = "drop" for = "_461"></label><div>{
          doActions(pTc);
          return IRule::Stop;
        }</div>
      }</div>
      return IRule::Continue;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to add class info to scope stack top

  class HandleClassDefinition : public IAction
  <input id = _474 type = "checkbox"><label class = "drop" for = "_474"></label><div>{
    Repository* p_Repos;

  public:
    HandleClassDefinition(Repository* pRepos)
    <input id = _479 type = "checkbox"><label class = "drop" for = "_479"></label><div>{
      p_Repos = pRepos;
    }</div>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _483 type = "checkbox"><label class = "drop" for = "_483"></label><div>{
      GrammarHelper::showParseDemo("Handle class definition: ", *pTc);

      p_Repos-&gt;currentAccess() = Access::priv;

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();
      size_t typeIndex;
      pTc-&gt;find("class", typeIndex);
      if (typeIndex &lt; pTc-&gt;size())
      <input id = _495 type = "checkbox"><label class = "drop" for = "_495"></label><div>{
        size_t nameIndex = typeIndex + 1;
        std::string name = (*pTc)[nameIndex];
        top-&gt;type_ = "class";
        top-&gt;name_ = name;
        top-&gt;package_ = p_Repos-&gt;package();
        p_Repos-&gt;AST().typeMap()[name] = top;
        GrammarHelper::showParse("class def", *pTc);
      }</div>
      else  // C#
      <input id = _505 type = "checkbox"><label class = "drop" for = "_505"></label><div>{
        pTc-&gt;find("interface", typeIndex);
        size_t nameIndex = typeIndex + 1;
        std::string name = (*pTc)[nameIndex];
        top-&gt;type_ = "interface";
        top-&gt;name_ = name;
        top-&gt;package_ = p_Repos-&gt;package();
        p_Repos-&gt;AST().typeMap()[name] = top;
        GrammarHelper::showParse("interface def", *pTc);
      }</div>
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // rule to detect struct statements

  class StructDefinition : public IRule
  <input id = _522 type = "checkbox"><label class = "drop" for = "_522"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _525 type = "checkbox"><label class = "drop" for = "_525"></label><div>{
      GrammarHelper::showParseDemo("Test struct definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      <input id = _530 type = "checkbox"><label class = "drop" for = "_530"></label><div>{
        size_t len;
        tc.find("struct", len);
        if (len &lt; tc.size())
        <input id = _534 type = "checkbox"><label class = "drop" for = "_534"></label><div>{
          doActions(pTc);
          return IRule::Stop;
        }</div>
      }</div>
      return IRule::Continue;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to add struct info to scope stack top

  class HandleStructDefinition : public IAction
  <input id = _547 type = "checkbox"><label class = "drop" for = "_547"></label><div>{
    Repository* p_Repos;

  public:
    HandleStructDefinition(Repository* pRepos)
    <input id = _552 type = "checkbox"><label class = "drop" for = "_552"></label><div>{
      p_Repos = pRepos;
    }</div>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _556 type = "checkbox"><label class = "drop" for = "_556"></label><div>{
      GrammarHelper::showParseDemo("Handle struct definition: ", *pTc);

      p_Repos-&gt;currentAccess() = Access::publ;

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();

      size_t pos;
      pTc-&gt;find("struct", pos);
      std::string name = (*pTc)[pos + 1];
      top-&gt;type_ = "struct";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();
      p_Repos-&gt;AST().typeMap()[name] = top;

      GrammarHelper::showParse("struct def", *pTc);
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // rule to detect C++ function definitions

  class CppFunctionDefinition : public IRule
  <input id = _582 type = "checkbox"><label class = "drop" for = "_582"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _585 type = "checkbox"><label class = "drop" for = "_585"></label><div>{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C++ function definition: ", *pTc);

      ScopeStack&lt;ASTNode*&gt;& stack = pRepo-&gt;scopeStack();
      if (stack.size() &lt; 2)
        return IRule::Continue;

      std::string parentType = stack.predOfTop()-&gt;type_;
      if (parentType != "namespace" && parentType != "class" && parentType != "struct")
        return IRule::Continue;

      const Lexer::ITokenCollection& tc = *pTc;

      if (tc[tc.size() - 1] == "{")
      <input id = _603 type = "checkbox"><label class = "drop" for = "_603"></label><div>{
        if (GrammarHelper::isFunction(*pTc))
        <input id = _605 type = "checkbox"><label class = "drop" for = "_605"></label><div>{
          doActions(pTc);
          return IRule::Stop;
        }</div>
      }</div>
      return IRule::Continue;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to add function info to scope stack top

  class HandleCppFunctionDefinition : public IAction
  <input id = _618 type = "checkbox"><label class = "drop" for = "_618"></label><div>{
    Repository* p_Repos;

  public:
    HandleCppFunctionDefinition(Repository* pRepos)
    <input id = _623 type = "checkbox"><label class = "drop" for = "_623"></label><div>{
      p_Repos = pRepos;
    }</div>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _627 type = "checkbox"><label class = "drop" for = "_627"></label><div>{
      GrammarHelper::showParseDemo("Handle C++ function definition: ", *pTc);

      ScopeStack&lt;ASTNode*&gt;& stack = p_Repos-&gt;scopeStack();
     
      if (stack.size() == 0)
        return;

      ASTNode* top = stack.top();

      size_t nameIndex;
      if(pTc-&gt;find("(", nameIndex))
      --nameIndex;
      else return;
      std::string name = (*pTc)[nameIndex];

      // is function a destructor?

      if (nameIndex &gt; 0 && (*pTc)[nameIndex - 1] == "~")
      <input id = _646 type = "checkbox"><label class = "drop" for = "_646"></label><div>{
        --nameIndex;
        name = "~" + name;
      }</div>

      top-&gt;type_ = "function";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();
      GrammarHelper::showParse("function def", *pTc);

      // is function an operator?

      size_t operIndex;
      pTc-&gt;find("operator", operIndex);
      if (operIndex &lt; pTc-&gt;size())
      <input id = _661 type = "checkbox"><label class = "drop" for = "_661"></label><div>{
        name = "operator" + (*pTc)[operIndex + 1];// +(*pTc)[operIndex + 2];
        if ((*pTc)[operIndex + 2] != "(")
          name += (*pTc)[operIndex + 2];
        top-&gt;name_ = name;
        nameIndex = operIndex;
      }</div>
      // is function a member of a class or struct?

      if (nameIndex &gt; 1 && (*pTc)[nameIndex - 1] == "::")
      <input id = _671 type = "checkbox"><label class = "drop" for = "_671"></label><div>{
        //----&lt; start find class name &gt;--------------------

        std::string className = (*pTc)[nameIndex - 2];

        // is class a template?

        if (className == "&gt;")
        <input id = _679 type = "checkbox"><label class = "drop" for = "_679"></label><div>{
          size_t startParam = GrammarHelper::findLast(*pTc, "&lt;");
          if (0 &lt; startParam && startParam &lt; pTc-&gt;size())
            className = (*pTc)[startParam - 1];
        }</div>
        //----&lt; end find class name &gt;----------------------
<input id = _690 type = "checkbox"><label class = "drop" for = "_690"></label><div>        /*
        * - this function's ASTNode is at stack top
        * - find ASTNode of function's class
        * - unlink function ASTNode from stack top predecessor
        * - relink function ASTNode to it's class ASTNode
        * - leave function ASTNode on stack top as it may have child nodes
        */</div>
        ASTNode* pClassNode = p_Repos-&gt;AST().find(className);
        if (pClassNode == nullptr)
          return;
        if (p_Repos-&gt;scopeStack().size() &lt; 2)
          return;

        ASTNode* pFunctNode = p_Repos-&gt;scopeStack().top();
        ASTNode* pParentNode = p_Repos-&gt;scopeStack().predOfTop();
        if(pParentNode-&gt;children_.size() &gt; 0)
          pParentNode-&gt;children_.pop_back();           // unlink function
        pFunctNode-&gt;parentType_ = pClassNode-&gt;type_;
        pClassNode-&gt;children_.push_back(pFunctNode);   // relink function
        return;
      }</div>
      // is this a lambda?

      std::string packageName = p_Repos-&gt;package();
      std::string ext = FileSystem::Path::getExt(packageName);

      size_t posOpenBracket;
      pTc-&gt;find("[", posOpenBracket);
      size_t posCloseBracket;
      pTc-&gt;find("]", posCloseBracket);
      size_t posBrace;
      pTc-&gt;find("{", posBrace);
      size_t posOpenParen;
      pTc-&gt;find("(", posOpenParen);
      if (posCloseBracket != posBrace + 1 && posCloseBracket != posOpenParen + 1) // []{ or [](
        return;
      if (posOpenBracket &lt; posCloseBracket && posBrace == (posCloseBracket + 1) && posBrace &lt; pTc-&gt;size())
      <input id = _722 type = "checkbox"><label class = "drop" for = "_722"></label><div>{
        std::string name;
        for (size_t i = posOpenBracket; i &lt; posBrace; ++i)
          name += (*pTc)[i];
        top-&gt;name_ = name;
        top-&gt;type_ = "lambda";
      }</div>
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // rule to detect C# function definitions

  class CSharpFunctionDefinition : public IRule
  <input id = _736 type = "checkbox"><label class = "drop" for = "_736"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _739 type = "checkbox"><label class = "drop" for = "_739"></label><div>{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::CSharp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C# function definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      <input id = _748 type = "checkbox"><label class = "drop" for = "_748"></label><div>{
        Lexer::Semi se;
        for (size_t i = 0; i &lt; tc.size(); ++i)
          se.add(tc[i]);

        if (GrammarHelper::isFunction(se))
        <input id = _754 type = "checkbox"><label class = "drop" for = "_754"></label><div>{
          doActions(&se);
          return IRule::Stop;
        }</div>
      }</div>
      return IRule::Continue;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to add function info to scope stack top

  class HandleCSharpFunctionDefinition : public IAction
  <input id = _767 type = "checkbox"><label class = "drop" for = "_767"></label><div>{
    Repository* p_Repos;

  public:
    HandleCSharpFunctionDefinition(Repository* pRepos)
    <input id = _772 type = "checkbox"><label class = "drop" for = "_772"></label><div>{
      p_Repos = pRepos;
    }</div>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _776 type = "checkbox"><label class = "drop" for = "_776"></label><div>{
      GrammarHelper::showParseDemo("Handle C# function definition: ", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();

      size_t nameIndex;
      if (pTc-&gt;find("(", nameIndex))
        --nameIndex;
      else
        return;

      std::string name = (*pTc)[nameIndex];

      // is function a destructor?

      if (nameIndex &gt; 0 && (*pTc)[nameIndex - 1] == "~")
      <input id = _795 type = "checkbox"><label class = "drop" for = "_795"></label><div>{
        --nameIndex;
        name = "~" + name;
      }</div>

      top-&gt;type_ = "function";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();

      GrammarHelper::showParse("function def", *pTc);

      // is function an operator?

      size_t operIndex;
      pTc-&gt;find("operator", operIndex);
      if (operIndex &lt; pTc-&gt;size())
      <input id = _811 type = "checkbox"><label class = "drop" for = "_811"></label><div>{
        name = "operator" + (*pTc)[operIndex + 1] + (*pTc)[operIndex + 2];
        top-&gt;name_ = name;
        nameIndex = operIndex;
      }</div>

      // is lambda?

      size_t posParen;
      pTc-&gt;find("(", posParen);
      size_t posBrace;
      pTc-&gt;find("{", posBrace);
      size_t posEqual;
      pTc-&gt;find("=", posEqual);
      if (posParen &lt; posBrace && posBrace &lt; pTc-&gt;size())
      <input id = _826 type = "checkbox"><label class = "drop" for = "_826"></label><div>{
        if (posEqual &lt; pTc-&gt;size() - 1 && (*pTc)[posEqual + 1] == "&gt;")
        <input id = _828 type = "checkbox"><label class = "drop" for = "_828"></label><div>{
          std::string name;
          for (size_t i = posParen; i &lt;= posBrace; ++i)
            name += (*pTc)[i];
          top-&gt;name_ = name;
          top-&gt;type_ = "lambda";
        }</div>
      }</div>
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // rule to detect control definitions

  class ControlDefinition : public IRule
  <input id = _843 type = "checkbox"><label class = "drop" for = "_843"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _846 type = "checkbox"><label class = "drop" for = "_846"></label><div>{
      GrammarHelper::showParseDemo("Test control definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      <input id = _851 type = "checkbox"><label class = "drop" for = "_851"></label><div>{
        size_t len;
        tc.find("(", len);
        if (len &lt; tc.size() && GrammarHelper::isControlKeyWord(tc[len - 1]))
        <input id = _855 type = "checkbox"><label class = "drop" for = "_855"></label><div>{
          doActions(pTc);
          return IRule::Stop;
        }</div>
        else if (tc.size() &gt; 1 && GrammarHelper::isControlKeyWord(tc[tc.size() - 2]))
        <input id = _860 type = "checkbox"><label class = "drop" for = "_860"></label><div>{
          doActions(pTc);
          return IRule::Stop;
        }</div>
      }</div>
      return IRule::Continue;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to add control info to scope stack top

  class HandleControlDefinition : public IAction
  <input id = _873 type = "checkbox"><label class = "drop" for = "_873"></label><div>{
    Repository* p_Repos;

  public:
    HandleControlDefinition(Repository* pRepos)
    <input id = _878 type = "checkbox"><label class = "drop" for = "_878"></label><div>{
      p_Repos = pRepos;
    }</div>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _882 type = "checkbox"><label class = "drop" for = "_882"></label><div>{
      GrammarHelper::showParseDemo("Handle control definition: ", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top;
      if ((p_Repos-&gt;scopeStack()).size() &gt; 0)
        top = p_Repos-&gt;scopeStack().top();
      else
        return;

      size_t nameIndex;
      if(pTc-&gt;find("(", nameIndex))         // if, for, while, switch, catch
        --nameIndex;
      //if (nameIndex == pTc-&gt;size() - 1)     // do, try - they don't have parens
      else
        nameIndex = pTc-&gt;size() - 2;
      std::string name = (*pTc)[nameIndex];
      top-&gt;type_ = "control";
      top-&gt;name_ = name;

      GrammarHelper::showParse("control def", *pTc);
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to send semi-expression that starts a function def
  // to console

  class PrintFunction : public IAction
  <input id = _913 type = "checkbox"><label class = "drop" for = "_913"></label><div>{
    Repository* p_Repos;
  public:
    using Rslt = Logging::StaticLogger&lt;0&gt;;

    PrintFunction(Repository* pRepos)
    <input id = _919 type = "checkbox"><label class = "drop" for = "_919"></label><div>{
      p_Repos = pRepos;
    }</div>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _923 type = "checkbox"><label class = "drop" for = "_923"></label><div>{
      std::ostringstream out;
      //out &lt;&lt; "\n  FuncDef: " &lt;&lt; pTc-&gt;show().c_str();
      Rslt::write(out.str());
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to send signature of a function def to console

  class PrettyPrintFunction : public IAction
  <input id = _934 type = "checkbox"><label class = "drop" for = "_934"></label><div>{
    Repository* p_Repos;
  public:
    using Rslt = Logging::StaticLogger&lt;0&gt;;

    PrettyPrintFunction(Repository* pRepos) : p_Repos(pRepos) <input id = _939 type = "checkbox"><label class = "drop" for = "_939"></label><div>{}</div>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _942 type = "checkbox"><label class = "drop" for = "_942"></label><div>{
      size_t len;
      pTc-&gt;find(")", len);

      std::ostringstream out;
      out &lt;&lt; "\n\n  Pretty Stmt:    ";
      for (size_t i = 0; i &lt; len + 1; ++i)
        out &lt;&lt; (*pTc)[i] &lt;&lt; " ";
      out &lt;&lt; "\n";
      Rslt::write(out.str());
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // rule to detect C++ Declaration
<input id = _962 type = "checkbox"><label class = "drop" for = "_962"></label><div>  /*
  *  - Declaration ends in semicolon
  *  - has type, name, modifiers & initializers
  *  So:
  *  - strip off modifiers and initializers
  *  - if you have two things left it's a declar, else executable
  */</div>
  class CppDeclaration : public IRule
  <input id = _965 type = "checkbox"><label class = "drop" for = "_965"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _968 type = "checkbox"><label class = "drop" for = "_968"></label><div>{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C++ declaration: ", *pTc);

      Lexer::Semi tc;
      tc.clone(*pTc);

      // begin added 2/26/2017

      Access access = pRepo-&gt;currentAccess();
      bool isPublic = false;

      if (pRepo-&gt;scopeStack().size() == 0)
        return false;

      std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;

      size_t posPrivate;
      pTc-&gt;find("private", posPrivate);
      if (posPrivate &lt; pTc-&gt;size())
      <input id = _991 type = "checkbox"><label class = "drop" for = "_991"></label><div>{
        isPublic = false;
        pRepo-&gt;currentAccess() = Access::priv;
      }</div>

      size_t posProtected;
      pTc-&gt;find("protected", posProtected);
      if (posProtected &lt; pTc-&gt;size())
      <input id = _999 type = "checkbox"><label class = "drop" for = "_999"></label><div>{
        isPublic = false;
        pRepo-&gt;currentAccess() = Access::prot;
      }</div>

      size_t posPublic;
      pTc-&gt;find("public", posPublic);
      if (posPublic &lt; pTc-&gt;size() && parentType != "function")
      <input id = _1007 type = "checkbox"><label class = "drop" for = "_1007"></label><div>{
        isPublic = true;
        pRepo-&gt;currentAccess() = Access::publ;
      }</div>

      // end added 2/26/2017

      if (tc.size() &gt; 0 && tc[0] == "using")
      <input id = _1015 type = "checkbox"><label class = "drop" for = "_1015"></label><div>{
        doActions(pTc);
        return IRule::Stop;
      }</div>

      if (tc[tc.size() - 1] == ";" && tc.size() &gt; 2)
      <input id = _1021 type = "checkbox"><label class = "drop" for = "_1021"></label><div>{
        std::string nextToLast = tc[tc.size() - 2];
        if (nextToLast == "delete" || nextToLast == "default" || nextToLast == "const")
        <input id = _1024 type = "checkbox"><label class = "drop" for = "_1024"></label><div>{
          <input id = _1025 type = "checkbox"><label class = "drop" for = "_1025"></label><div>{
            // function declaration
            doActions(pTc);
            return IRule::Stop;
          }</div>
        }</div>
        std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;
        
        if (GrammarHelper::isDataDeclaration(tc) || GrammarHelper::isFunctionDeclaration(tc, parentType))
        <input id = _1034 type = "checkbox"><label class = "drop" for = "_1034"></label><div>{
          doActions(pTc);
          return IRule::Stop;
        }</div>

        if (parentType != "function")
        <input id = _1040 type = "checkbox"><label class = "drop" for = "_1040"></label><div>{
          // can't be executable so must be declaration

          doActions(pTc);
          return IRule::Stop;
        }</div>
      }</div>
      return IRule::Continue;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to add declaration info to scope stack top

  class HandleCppDeclaration : public IAction
  <input id = _1055 type = "checkbox"><label class = "drop" for = "_1055"></label><div>{
    Repository* p_Repos;

  public:
    HandleCppDeclaration(Repository* pRepos) : p_Repos(pRepos) <input id = _1059 type = "checkbox"><label class = "drop" for = "_1059"></label><div>{}</div>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _1062 type = "checkbox"><label class = "drop" for = "_1062"></label><div>{
      GrammarHelper::showParseDemo("Handle C++ declaration: ", *pTc);

      // save declaration info in ASTNode

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* pCurrNode = p_Repos-&gt;scopeStack().top();
      DeclarationNode declNode;
      declNode.access_ = p_Repos-&gt;currentAccess();
      declNode.pTc = pTc-&gt;clone();
      declNode.package_ = p_Repos-&gt;package();
      declNode.line_ = p_Repos-&gt;lineCount();

      Lexer::Semi se;
      se.clone(*pTc);
      GrammarHelper::removeComments(se);

      if (se[0] == "using")
      <input id = _1082 type = "checkbox"><label class = "drop" for = "_1082"></label><div>{
        declNode.declType_ = DeclType::usingDecl;
        pCurrNode-&gt;decl_.push_back(declNode);

        GrammarHelper::showParse("using declar", *pTc);
        return;
      }</div>

      if (GrammarHelper::isFunctionDeclaration(se,"parentNotFunction"))
      <input id = _1091 type = "checkbox"><label class = "drop" for = "_1091"></label><div>{
        return;
      }</div>

      if (GrammarHelper::isDataDeclaration(se))
      <input id = _1096 type = "checkbox"><label class = "drop" for = "_1096"></label><div>{
        declNode.declType_ = DeclType::dataDecl;
        pCurrNode-&gt;decl_.push_back(declNode);
        GrammarHelper::showParse("data declar", *pTc);
      }</div>
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // rule to detect C# Declaration
<input id = _1111 type = "checkbox"><label class = "drop" for = "_1111"></label><div>  /*
  *  - Declaration ends in semicolon
  *  - has type, name, modifiers & initializers
  *  So:
  *  - strip of modifiers and initializers
  *  - if you have two things left it's a declar, else executable
  */</div>
  class CSharpDeclaration : public IRule
  <input id = _1114 type = "checkbox"><label class = "drop" for = "_1114"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _1117 type = "checkbox"><label class = "drop" for = "_1117"></label><div>{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::CSharp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C# declaration: ", *pTc);

      Access access = pRepo-&gt;currentAccess();
      bool isPublic = false;

      if (pRepo-&gt;scopeStack().size() == 0)
        return false;

      std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;

      size_t posPublic;
      pTc-&gt;find("public", posPublic);
      if (posPublic &lt; pTc-&gt;size() && parentType != "function")
      <input id = _1135 type = "checkbox"><label class = "drop" for = "_1135"></label><div>{
        isPublic = true;
        pRepo-&gt;currentAccess() = Access::publ;
      }</div>

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc.size() &gt; 0 && tc[0] == "using")
      <input id = _1142 type = "checkbox"><label class = "drop" for = "_1142"></label><div>{
        doActions(pTc);
        pRepo-&gt;currentAccess() = access;
        return IRule::Stop;
      }</div>

      Lexer::Semi se;
      se.clone(*pTc);

      if (GrammarHelper::isDataDeclaration(se))
      <input id = _1152 type = "checkbox"><label class = "drop" for = "_1152"></label><div>{
        doActions(pTc);
        pRepo-&gt;currentAccess() = access;
        return IRule::Stop;
      }</div>

      if (GrammarHelper::isFunctionDeclaration(se, parentType))
      <input id = _1159 type = "checkbox"><label class = "drop" for = "_1159"></label><div>{
        doActions(pTc);
        pRepo-&gt;currentAccess() = access;
        return IRule::Stop;
      }</div>
      return IRule::Continue;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to add declaration info to scope stack top

  class HandleCSharpDeclaration : public IAction
  <input id = _1172 type = "checkbox"><label class = "drop" for = "_1172"></label><div>{
    Repository* p_Repos;

  public:
    HandleCSharpDeclaration(Repository* pRepos) : p_Repos(pRepos) <input id = _1176 type = "checkbox"><label class = "drop" for = "_1176"></label><div>{}</div>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _1179 type = "checkbox"><label class = "drop" for = "_1179"></label><div>{
      GrammarHelper::showParseDemo("Handle C# declaration: ", *pTc);

      // store declaration info in ASTNode

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* pCurrNode = p_Repos-&gt;scopeStack().top();
      DeclarationNode declNode;
      declNode.access_ = p_Repos-&gt;currentAccess();
      declNode.pTc = pTc-&gt;clone();
      declNode.package_ = p_Repos-&gt;package();
      declNode.line_ = p_Repos-&gt;lineCount();

      Lexer::Semi se;
      se.clone(*pTc);
      GrammarHelper::removeComments(se);

      if (se[0] == "using")
      <input id = _1199 type = "checkbox"><label class = "drop" for = "_1199"></label><div>{
        declNode.declType_ = DeclType::usingDecl;
        pCurrNode-&gt;decl_.push_back(declNode);

        GrammarHelper::showParse("using declar", *pTc);
        return;
      }</div>

      std::string parentType = p_Repos-&gt;scopeStack().top()-&gt;type_;

      if (GrammarHelper::isFunctionDeclaration(se, parentType))
      <input id = _1210 type = "checkbox"><label class = "drop" for = "_1210"></label><div>{
        Access adebug = declNode.access_;
        declNode.declType_ = DeclType::functionDecl;
        pCurrNode-&gt;decl_.push_back(declNode);
        GrammarHelper::showParse("function declar", *pTc);
      }</div>
      else
      <input id = _1217 type = "checkbox"><label class = "drop" for = "_1217"></label><div>{
        Access adebug = declNode.access_;
        declNode.declType_ = DeclType::dataDecl;
        pCurrNode-&gt;decl_.push_back(declNode);
        GrammarHelper::showParse("data declar", *pTc);
      }</div>
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // rule to detect C++ Executable

  class CppExecutable : public IRule
  <input id = _1230 type = "checkbox"><label class = "drop" for = "_1230"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _1233 type = "checkbox"><label class = "drop" for = "_1233"></label><div>{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C++ executable: ", *pTc);

      Lexer::Semi tc;
      tc.clone(*pTc);

      if (tc[tc.size() - 1] == ";" && tc.size() &gt; 2)
      <input id = _1244 type = "checkbox"><label class = "drop" for = "_1244"></label><div>{
        GrammarHelper::removeFunctionArgs(tc);
        GrammarHelper::condenseTemplateTypes(tc);

        // remove modifiers, comments, newlines, returns, and initializers

        Lexer::Semi se;
        for (size_t i = 0; i &lt; tc.size(); ++i)
        <input id = _1252 type = "checkbox"><label class = "drop" for = "_1252"></label><div>{
          if (GrammarHelper::isQualifierKeyWord(tc[i]))
            continue;
          if (se.isComment(tc[i]) || tc[i] == "\n" || tc[i] == "return")
            continue;
          if (tc[i] == "=" || tc[i] == ";")
          <input id = _1258 type = "checkbox"><label class = "drop" for = "_1258"></label><div>{
            se.add(";");
            break;
          }</div>
          else
            se.add(tc[i]);
        }</div>
        if (se.size() != 3)  // not a declaration
        <input id = _1266 type = "checkbox"><label class = "drop" for = "_1266"></label><div>{
          doActions(pTc);
          return IRule::Stop;
        }</div>
      }</div>
      return IRule::Continue;
    }</div>
  };
</div>
  ///////////////////////////////////////////////////////////////
  // action to display C++ executable info

  class HandleCppExecutable : public IAction
  <input id = _1279 type = "checkbox"><label class = "drop" for = "_1279"></label><div>{
    Repository* p_Repo;

  public:
    HandleCppExecutable(Repository* pRepo) : p_Repo(pRepo) <input id = _1283 type = "checkbox"><label class = "drop" for = "_1283"></label><div>{}</div>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _1286 type = "checkbox"><label class = "drop" for = "_1286"></label><div>{
      GrammarHelper::showParseDemo("Handle C++ executable: ", *pTc);

      GrammarHelper::showParse("executable", *pTc);
    }</div>
  };
  ///////////////////////////////////////////////////////////////</div>
  // rule to detect C# Executable

  class CSharpExecutable : public IRule
  <input id = _1296 type = "checkbox"><label class = "drop" for = "_1296"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _1299 type = "checkbox"><label class = "drop" for = "_1299"></label><div>{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::CSharp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C# executable: ", *pTc);

      const Lexer::ITokenCollection& in = *pTc;
      Lexer::Semi tc;
      for (size_t i = 0; i &lt; in.size(); ++i)
        tc.add(in[i]);

      if (tc[tc.size() - 1] == ";" && tc.size() &gt; 2)
      <input id = _1312 type = "checkbox"><label class = "drop" for = "_1312"></label><div>{
        GrammarHelper::removeFunctionArgs(tc);
        GrammarHelper::condenseTemplateTypes(tc);

        // remove modifiers, comments, newlines, returns, and initializers

        Lexer::Semi se;
        for (size_t i = 0; i &lt; tc.size(); ++i)
        <input id = _1320 type = "checkbox"><label class = "drop" for = "_1320"></label><div>{
          if (GrammarHelper::isQualifierKeyWord(tc[i]))
            continue;
          if (se.isComment(tc[i]) || tc[i] == "\n" || tc[i] == "return")
            continue;
          if (tc[i] == "=" || tc[i] == ";")
          <input id = _1326 type = "checkbox"><label class = "drop" for = "_1326"></label><div>{
            se.add(";");
            break;
          }</div>
          else
            se.add(tc[i]);
        }</div>
        if (se.size() != 3)  // not a declaration
        <input id = _1334 type = "checkbox"><label class = "drop" for = "_1334"></label><div>{
          doActions(pTc);
          return IRule::Stop;
        }</div>
      }</div>
      return IRule::Continue;
    }</div>
  };
  ///////////////////////////////////////////////////////////////</div>
  // action to display C# executable info

  class HandleCSharpExecutable : public IAction
  <input id = _1346 type = "checkbox"><label class = "drop" for = "_1346"></label><div>{
    Repository* p_Repo;

  public:
    HandleCSharpExecutable(Repository* pRepo) : p_Repo(pRepo) <input id = _1350 type = "checkbox"><label class = "drop" for = "_1350"></label><div>{}</div>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _1353 type = "checkbox"><label class = "drop" for = "_1353"></label><div>{
      GrammarHelper::showParseDemo("Handle C# executable: ", *pTc);

      Lexer::Semi se;
      se.clone(*pTc);
      GrammarHelper::removeComments(se);

      GrammarHelper::showParse("executable", se);
    }</div>
  };
  ///////////////////////////////////////////////////////////////</div>
  // default rule
  // - this is here to catch any Semi that didn't parse
  // - We don't have rule for enums, so they are caugth here

  class Default : public IRule
  <input id = _1369 type = "checkbox"><label class = "drop" for = "_1369"></label><div>{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <input id = _1372 type = "checkbox"><label class = "drop" for = "_1372"></label><div>{
      GrammarHelper::showParseDemo("Test default: ", *pTc);

      doActions(pTc);  // catches everything
      return IRule::Stop;
    }</div>
  };
  ///////////////////////////////////////////////////////////////</div>
  // action to display default info

  class HandleDefault : public IAction
  <input id = _1383 type = "checkbox"><label class = "drop" for = "_1383"></label><div>{
    Repository* p_Repo;

  public:
    HandleDefault(Repository* pRepo) : p_Repo(pRepo) <input id = _1387 type = "checkbox"><label class = "drop" for = "_1387"></label><div>{}</div>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <input id = _1390 type = "checkbox"><label class = "drop" for = "_1390"></label><div>{
      GrammarHelper::showParseDemo("Handle default: ", *pTc);
      GrammarHelper::showParse("default: ", *pTc);
    }</div>
  };
}</div></div>
#endif
    </pre>
  </body>
</html>
